/** @module phxutils
 * @requires phxerrors
 * @requires typecheck
 * @summary Provides utility functions for the Phoenix system
 */

require('phxerrors');
const tc = require('typecheck').getInstance();
const CLASSNAME = '';
const APPROOT = '/home/null/pdc/cmrs2-v3';

const types = [ 'mzps', // 0
                'rgb', // 1
                'rgb-linear', // 2
                'sdclc', // 3
                'apc', // 4
                'gefen', // 5
                'hall', // 6
                'mcb', // 7
              ];


const typeMap = ( ascii ) => {
  let iMax = types.length;
  for( let i = 0; i < iMax; i++ ) {
    if( types[i] == ascii )
      return i;
  }
  return -1;
}

/** Checks if a variable is undefined
 * @param {Volatile} el - Variable to check for existence
 * @param {String} [name] - Name to attach to error message
 * @throws {MissingArgError} if el undefined
 * @returns {Volatile} el
 * @static
 */
const exists = function( el, n ) {
  if( el === undefined ) {
    let msg = n !== undefined ? `${n} must be defined` : 'Necessary variable is undefined';
    throw new MissingArgError('','', msg);
  }
  return el;
}
/** Checks if variable is of specified type
 * @param {Volatile} el - Variable to check
 * @param {Volatile} type - Type to verify
 * @param {String} [name] - Name to use in error message
 * @throws {MissingArgError} If el is undefined
 * @throws {MissingArgError} If type is undefined
 * @throws {ArgTypeError} If el is not correct type
 * @requires {typecheck}
 * @returns {Volatile} el
 * @static
 */
const is = function(el, type, n) {
  exists( el, n );
  exists( type )
  try { tc.assert(el, type) }
  catch(err) {
    let msg = n === undefined ? `${n} must be of type `: 'Argument must be of type ';
    if( type.name === undefined )
      msg = msg + type;
    else
      msg = msg + type.name;
    throw new ArgTypeError('','',msg);
  }
  return el;
}
/** Determines list of IPv4 addresses associated with active interfaces.
 * @returns {String[]} - IP addresses
 * @throws {IPValueError} If no interfaces are assigned an IPv4 address
 * @requires {os}
 * @static
 */
const localIPs = () => {
  let ret = [];
  ifaces = require('os').networkInterfaces()
  Object.keys( ifaces ).forEach( (i) => {
    ifaces[i].forEach( (v) => {
      if( !v.internal && v.family == 'IPv4' )
        ret.push( v.address )
    });
  });
  if( ret.length == 0 )
    throw new IPValueError('','','Host has no interfaces with an IPv4 address');
  return ret;
}
/** Checks an IP for valid format and that destination is on a subnet with the host. Assumes a   /24 subnet
 * @param {String} ip
 * @returns {String} ip
 * @throws {MissingArgError} If ip is undefined
 * @throws {ArgTypeError} If ip is not a string
 * @throws {IPValueError} If ip does not contain 4 octets
 * @throws {IPValueError} If an octet has an ascii length greater than 3
 * @throws {IPValueError} If an octet has an integer value not between 0 and 255
 * @throws {IPValueError} If ip is not on a subnet with the host
 * @static
 */
const checkIP = (ip) => {
  let ipArr = is( exists( ip, 'ip' ), 'string', 'ip' ).split('.');
  if(ipArr.length != 4)
    throw new IPValueError('','',`${ip} has invalid IP length`);
  ipArr.forEach( ( octet ) => {
    if(octet.length > 3)
      throw new IPValueError('','',`${ip} contains invalid octet length: ${octet}`);
    try { is( parseInt(octet), '0..255' ); }
    catch(e) { throw new IPValueError('','',`${ip} has out of range octet: ${octet}`) }
  });
  if( process.env.IGNORE_IP_SUBNET_CHECK == 1 )
    return ip;
  let valid = false;
  let subnet = ip.substring( 0, ip.lastIndexOf('.') );
  localIPs().forEach( (iface) => {
    if( valid ) return;
    if(iface.startsWith(subnet) ) valid = true;
  });
  if(!valid )
    throw new IPValueError('','',`${ip} is not on a subnet with host`);
  return ip;
}
/** Parses a utf8/ascii string of XML into an array of integers of length n. Skips the first line and assumes attributes are seperated by a windows new line (\r\n)
 * @param {String} xml - XML to parse
 * @param {Integer} [n] - Length of array to generate/lines to parse. Defaults to 16
 * @returns {Integer[]} - Integer array of size n
 * @throws {ArgTypeError} If n is not an integer
 * @throws {ArgValueError} If n less than 1 or longer than the supplied XML
 */
const xml2array = (xml, n) => {
  let METHODNAME = 'xml2array(xml, [n])';
  try{ is( xml, 'string', 'xml') }
  catch(err) {
    let e;
    switch(err.name) {
      case 'MissingArgError': e = MissingArgError; break;
      case 'ArgTypeError': e = ArgTypeError; break;
    }
    throw new e(CLASSNAME, METHODNAME, err.message);
  }
  let len;
  xmlArr = xml.split('>\r\n<');
  try {
    len = exists(n, 'n')
    if( len < 1 || len > xmlArr.length - 2 )
      throw new ArgValueError(CLASSNAME, METHODNAME, 'n', n);
  }
  catch(err) {
    if(err.name == 'MissingArgError' )
      len = 16;
    else
      throw err;
  }
  let output = [];
  for(let i = 1; i <= len; i++) {
    cur = xmlArr[i];
    cur = cur.substring(cur.indexOf('>')+1, cur.indexOf('<'));
    output.push(parseInt(cur));
  }
  return output;
}

const errorFallThrough = (err) => {
  console.log(`Unhandled ${err.name} - ${err.code} '${err.message}'`);
  throw err;
};
/**
* Throws the proper error based on 'err' that gets passed in
* @param CLASSNAME {String} Name of the class throwing the error
* @param METHODNAME {String} Name of the method throwing the error
* @param err {Object} Error information
* @returns {void}
*/
const errSwitcher = (CLASSNAME, METHODNAME, err) => {
  let e;
  switch( err.name ) {
    case 'IPValueError': e = IPValueError; break;
    case 'MissingArgError': e = MissingArgError; break;
    case 'ArgTypeError': e = ArgTypeError; break;
    case 'ArgValueError': throw err; break;
    case 'StateError': e = StateError; break;
    case 'DeviceStateError': e = DeviceStateError; break;
    case 'SystemError': e = SystemError; break;
    default: errorFallThrough(err);
  }
  throw new e(CLASSNAME, METHODNAME, err.message);
}

module.exports = {
  APPROOT : APPROOT,
  checkIP : checkIP,
  tc : tc,
  exists : exists,
  is : is,
  localIPs : localIPs,
  xml2array : xml2array,
  errorFallThrough : errorFallThrough,
  errSwitcher : errSwitcher,
  artnetHeader : Buffer.from('Art-Net\u0000\u0000P\u0000\u000e\u0000\u0000\u0000\u0000\u0002\u0000', 'utf8'),
  typeMap : typeMap,
  types : types,
  xml2arrayParser : (n) => { return (xml) => xml2array(xml, n) }
}
